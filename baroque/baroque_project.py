import os
import sys


class BaroqueProject(object):
    """
    Stores details about the current project.

    It takes a path to a source directory and a path to a destination directory:
    - the source directory can be either a shipment-level, collection-level, or item-level directory.
    - the destination directory stores reports generated by baroque.

    It characterizes the source directory level by analyzing what is inside the source directory.
    Then, it parses the source directory recursively down to the item-level.

    An initial instantiation of this object might look like:
    {
        "source": source_directory,
        "destination": destination_directory
        "shipment" : [
            {
            "id": "",
            "path": "",
            }
        ]
        "collections" : [
            {
            "id": "",
            "path": "",
            }
        ]
        "items": [
            {
            "id": "",
            "path": "",
            "files": {
                "wav": [],
                "mp3": [],
                "jpg": [],
                "xml": [],
                "md5": [],
                "txt": [],
                "other": []
            },
            "errors": []
            }
        ],
    }
    """

    def __init__(self, source_directory, destination_directory):
        if not os.path.exists(source_directory):
            print("ERROR: source_directory does not exist")
            sys.exit()
        if not os.path.exists(destination_directory):
            print("ERROR: destination_directory does not exist")
            sys.exit()

        self.source_directory = source_directory
        self.destination_directory = destination_directory

        self.shipment = []
        self.collections = []
        self.items = []

        self.source_type = self.characterize_source_directory()
        print("SYSTEM: source_directory is {}".format(self.source_type))
        if self.source_type == "shipment":
            self.parse_shipment(source_directory)
        elif self.source_type == "collection":
            self.parse_collection(source_directory)
        elif self.source_type == "item":
            self.parse_item(source_directory)

    def characterize_source_directory(self):
        """
        Characterize the source directory level by analyzing what is inside the source directory.
        """
        character_directory_name = os.path.basename(self.source_directory)
        character_directory_dirs = []
        character_directory_files = []

        # Loop the source directory to get files and sub-directories and append their name into respective lists
        for dir_entry in os.scandir(self.source_directory):
            if dir_entry.is_file():
                character_directory_files.append(str(dir_entry.name))
            elif dir_entry.is_dir():
                character_directory_dirs.append(str(dir_entry.name))

        # Return the source directory level as "item", if the lists show the source directory
        # has files and does not have sub-directories
        if len(character_directory_files) > 0 and len(character_directory_dirs) == 0:
            if all([filename.startswith(character_directory_name) for filename in character_directory_files]):
                return "item"
            '''
            else:
                print("ERROR: source_directory looks like an item but has unexpected file names")
                sys.exit()
            '''
        elif len(character_directory_dirs) > 0:
            # Return the source directory level as "collection", if the lists show the source directory
            # has sub-directories and sub-directory names start with the source directory name
            if any([directory.startswith(character_directory_name) for directory in character_directory_dirs]):
                return "collection"

            # Return the source directory level as "shipment", if the lists show the source directory
            # has sub-directories and sub-directory names do not start with the source directory name
            else:
                return "shipment"

        # Exit when the source directory does not have files nor sub-directories
        else:
            print("ERROR: source_directory is empty")
            sys.exit()

    def parse_shipment(self, shipment_directory):
        """
        Take a shipment-level directory path, parse its id and directory path,
        and add a dictionary to the "shipment" attribute.
        Then, loop the shipment-level directory for collection-level directories,
        and run "parse_collection" method on each collection-level directory.
        """
        self.shipment.append({
            "id": os.path.basename(shipment_directory),
            "path": shipment_directory
        })

        for dir_entry in os.scandir(shipment_directory):
            if dir_entry.is_dir():
                self.parse_collection(dir_entry.path)

    def parse_collection(self, collection_directory):
        """
        Take a collection-level directory path, parse its id and directory path,
        and add a dictionary to the "collections" attribute.
        Then, loop the directory for collection-level directories,
        and run "parse_item" method on each item-level directory.
        """
        self.collections.append({
            "id": os.path.basename(collection_directory),
            "path": collection_directory
        })

        for dir_entry in os.scandir(collection_directory):
            if dir_entry.is_dir():
                self.parse_item(dir_entry.path)

    def parse_item(self, item_directory):
        """
        Take a item-level directory path, parse id, directory path, files by their file formats,
        and add a dictionary to the "items" attribute.
        """
        files = {"wav": [], "mp3": [], "jpg": [], "xml": [], "md5": [], "txt": [], "other": []}
        file_formats = {
            "wav": ["wav", "wave"],
            "mp3": ["mp3"],
            "jpg": ["jpg", "jpeg", "jpe", "jif", "jfif", "jfi"],
            "xml": ["xml"],
            "md5": ["md5"],
            "txt": ["txt"]
        }

        for file in os.listdir(item_directory):
            other = True
            extension = file.lower().split(".")[-1]

            for format, extensions in file_formats.items():
                if extension in extensions:
                    files[format].append(file)
                    other = False

            if other is True:
                files["other"].append(file)

        self.items.append({
            "id": os.path.basename(item_directory),
            "path": item_directory,
            "files": files
        })
